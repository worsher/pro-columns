{"version":3,"file":"pro-columns.cjs","sources":["../strategy/index.ts","../lib/columns.ts","../lib/component.ts"],"sourcesContent":["import { ProColumnsType } from \"../type\";\n\n// 策略合并\nconst merge = (ori: ProColumnsType.ColumnType, cur: ProColumnsType.Strategy): ProColumnsType.Strategy => {\n    // 如果原始 column 没有策略，直接返回当前策略\n    if (!ori.strategys || ori.strategys.length === 0) {\n        return cur\n    }\n\n    // 根据模式处理\n    if (cur.mode === 'replace') {\n        // replace 模式：直接返回当前策略\n        return cur\n    } else {\n        // merge 模式：合并所有策略函数\n        const mergedStrategies: ProColumnsType.StrategyItem[] = []\n\n        // 收集所有已存在的策略函数\n        ori.strategys.forEach(s => {\n            mergedStrategies.push(...s.strategy)\n        })\n\n        // 添加当前策略函数\n        mergedStrategies.push(...cur.strategy)\n\n        return {\n            mode: 'merge',\n            strategy: mergedStrategies\n        }\n    }\n}\n\n// 策略执行\nconst execute = (\n    column: ProColumnsType.ColumnType,\n    strategys: ProColumnsType.Strategy[],\n    scene?: ProColumnsType.Scene\n): ProColumnsType.ColumnType => {\n    let result = { ...column }\n\n    // 遍历所有策略配置\n    strategys.forEach(strategyConfig => {\n        // 检查策略是否适用于当前场景\n        if (strategyConfig.scene) {\n            const allowedScenes = Array.isArray(strategyConfig.scene)\n                ? strategyConfig.scene\n                : [strategyConfig.scene]\n\n            // 如果指定了场景，但当前场景不在列表中，则跳过\n            if (scene && !allowedScenes.includes(scene)) {\n                return\n            }\n        }\n\n        // 执行该策略配置中的所有策略函数\n        strategyConfig.strategy.forEach(strategyFn => {\n            // 每个策略函数接收当前 column 和场景，返回处理后的 column\n            const processed = strategyFn(result, scene)\n            // 合并处理结果\n            result = { ...result, ...processed }\n        })\n    })\n\n    // 清除策略配置，避免输出时包含\n    delete result.strategys\n\n    return result\n}\n\n// 策略类\nconst Strategy = (\n    columns: ProColumnsType.ColumnType[],\n    scene?: ProColumnsType.Scene\n): ProColumnsType.ColumnType[] => {\n    // 复制一份数据\n    const copyColumns = columns.map(column => ({ ...column }))\n    return copyColumns.map(column => {\n        if (column.strategys) {\n            column.strategys = column.strategys.map(strategy => {\n                return merge(column, strategy)\n            })\n            return execute(column, column.strategys, scene)\n        }\n        return column\n    })\n}\n\nexport default Strategy\n\n// 导出所有策略\nexport { default as Search } from './Search'\nexport { default as Sort } from './Sort'\nexport { default as Required } from './Required'\nexport { default as Placeholder } from './Placeholder'\nexport { default as Format } from './Format'\nexport { default as Tooltip } from './Tooltip'\nexport { default as DefaultValue } from './DefaultValue'\nexport { default as Width } from './Width'\n\n// 导出策略工具函数\nexport * from './utils'","import Strategy from '../strategy'\nimport { ProColumnsType } from '../type'\n\nexport type ColumnsProps = {\n  columns: ProColumnsType.ColumnType[]\n  enums?: Record<string, any>\n  scene?: ProColumnsType.Scene // 可选场景参数\n}\n\n/**\n * Columns 处理器\n * 功能：\n * 1. 处理 enums 映射：将字段中的 enumKey 转换为实际的 valueEnum\n * 2. 应用策略处理：通过 Strategy 处理器应用所有配置的策略（支持场景）\n * 3. 返回处理后的 columns\n */\nconst Columns = (props: ColumnsProps): ProColumnsType.ColumnType[] => {\n  const { columns, enums = {}, scene } = props\n\n  // 1. 处理 enums 映射\n  const columnsWithEnums = columns.map((column) => {\n    const processedColumn = { ...column }\n\n    // 如果 column 中有 enumKey，则从 enums 中查找对应的枚举值\n    if ('enumKey' in processedColumn && processedColumn.enumKey) {\n      const enumKey = processedColumn.enumKey as string\n      if (enums[enumKey]) {\n        processedColumn.valueEnum = enums[enumKey]\n      }\n      // 删除 enumKey，避免传递给组件\n      delete (processedColumn as any).enumKey\n    }\n\n    return processedColumn\n  })\n\n  // 2. 应用策略处理（传入场景参数）\n  const processedColumns = Strategy(columnsWithEnums, scene)\n\n  return processedColumns\n}\n\nexport default Columns","import { ProColumnsType } from '../type'\nimport Columns from './columns'\n\n/**\n * 组件适配器类型\n * 每个组件适配器需要实现 transform 方法，将通用的 columns 转换为特定组件的 columns 格式\n */\nexport type ComponentAdapter<T = any> = {\n  /**\n   * 组件名称\n   */\n  name: string\n  /**\n   * 对应的场景（用于自动推断）\n   */\n  scene?: ProColumnsType.Scene\n  /**\n   * 转换函数：将通用 columns 转换为组件特定的 columns\n   */\n  transform: (columns: ProColumnsType.ColumnType[]) => T[]\n}\n\n/**\n * 组件适配器注册表\n */\nconst adapters: Map<string, ComponentAdapter> = new Map()\n\n/**\n * 组件名称到场景的默认映射\n */\nconst sceneMap: Record<string, ProColumnsType.Scene> = {\n  proTable: 'table',\n  proForm: 'form',\n  proDescription: 'description',\n}\n\n/**\n * Component 组件管理器\n */\nconst Component = {\n  /**\n   * 注册组件适配器\n   * @param adapter 组件适配器\n   */\n  register(adapter: ComponentAdapter) {\n    adapters.set(adapter.name, adapter)\n  },\n\n  /**\n   * 获取组件适配器\n   * @param name 组件名称\n   */\n  getAdapter(name: string): ComponentAdapter | undefined {\n    return adapters.get(name)\n  },\n\n  /**\n   * 转换 columns 为指定组件的格式\n   * @param name 组件名称\n   * @param columns 原始 columns\n   * @param enums 枚举字典（可选）\n   * @param scene 场景（可选，如不提供则自动推断）\n   */\n  transform<T = any>(\n    name: string,\n    columns: ProColumnsType.ColumnType[],\n    enums?: Record<string, any>,\n    scene?: ProColumnsType.Scene\n  ): T[] {\n    const adapter = this.getAdapter(name)\n    if (!adapter) {\n      console.warn(`Component adapter \"${name}\" not found, returning original columns`)\n      return columns as any\n    }\n\n    // 推断场景：优先使用传入的 scene，其次使用适配器的 scene，最后使用默认映射\n    const inferredScene = scene || adapter.scene || sceneMap[name]\n\n    // 先应用策略处理（带场景和枚举）\n    const processedColumns = Columns({\n      columns,\n      enums,\n      scene: inferredScene,\n    })\n\n    // 再通过适配器转换格式\n    return adapter.transform(processedColumns)\n  },\n\n  /**\n   * 获取所有已注册的适配器名称\n   */\n  getAdapterNames(): string[] {\n    return Array.from(adapters.keys())\n  },\n\n  /**\n   * 清空所有适配器（主要用于测试）\n   */\n  clear() {\n    adapters.clear()\n  },\n}\n\nexport default Component"],"names":["merge","ori","cur","mergedStrategies","s","execute","column","strategys","scene","result","strategyConfig","allowedScenes","strategyFn","processed","Strategy","columns","strategy","Columns","props","enums","columnsWithEnums","processedColumn","enumKey","adapters","sceneMap","Component","adapter","name","inferredScene","processedColumns"],"mappings":"gFAGA,MAAMA,EAAQ,CAACC,EAAgCC,IAA0D,CAOrG,GALI,CAACD,EAAI,WAAaA,EAAI,UAAU,SAAW,GAK3CC,EAAI,OAAS,UAEb,OAAOA,EACJ,CAEH,MAAMC,EAAkD,CAAA,EAGxD,OAAAF,EAAI,UAAU,QAAQG,GAAK,CACvBD,EAAiB,KAAK,GAAGC,EAAE,QAAQ,CACvC,CAAC,EAGDD,EAAiB,KAAK,GAAGD,EAAI,QAAQ,EAE9B,CACH,KAAM,QACN,SAAUC,CAAA,CAElB,CACJ,EAGME,EAAU,CACZC,EACAC,EACAC,IAC4B,CAC5B,IAAIC,EAAS,CAAE,GAAGH,CAAA,EAGlB,OAAAC,EAAU,QAAQG,GAAkB,CAEhC,GAAIA,EAAe,MAAO,CACtB,MAAMC,EAAgB,MAAM,QAAQD,EAAe,KAAK,EAClDA,EAAe,MACf,CAACA,EAAe,KAAK,EAG3B,GAAIF,GAAS,CAACG,EAAc,SAASH,CAAK,EACtC,MAER,CAGAE,EAAe,SAAS,QAAQE,GAAc,CAE1C,MAAMC,EAAYD,EAAWH,EAAQD,CAAK,EAE1CC,EAAS,CAAE,GAAGA,EAAQ,GAAGI,CAAA,CAC7B,CAAC,CACL,CAAC,EAGD,OAAOJ,EAAO,UAEPA,CACX,EAGMK,EAAW,CACbC,EACAP,IAGoBO,EAAQ,QAAe,CAAE,GAAGT,GAAS,EACtC,IAAIA,GACfA,EAAO,WACPA,EAAO,UAAYA,EAAO,UAAU,IAAIU,GAC7BhB,EAAMM,EAAQU,CAAQ,CAChC,EACMX,EAAQC,EAAQA,EAAO,UAAWE,CAAK,GAE3CF,CACV,ECpECW,EAAWC,GAAqD,CACpE,KAAM,CAAE,QAAAH,EAAS,MAAAI,EAAQ,CAAA,EAAI,MAAAX,GAAUU,EAGjCE,EAAmBL,EAAQ,IAAKT,GAAW,CAC/C,MAAMe,EAAkB,CAAE,GAAGf,CAAA,EAG7B,GAAI,YAAae,GAAmBA,EAAgB,QAAS,CAC3D,MAAMC,EAAUD,EAAgB,QAC5BF,EAAMG,CAAO,IACfD,EAAgB,UAAYF,EAAMG,CAAO,GAG3C,OAAQD,EAAwB,OAClC,CAEA,OAAOA,CACT,CAAC,EAKD,OAFyBP,EAASM,EAAkBZ,CAAK,CAG3D,ECfMe,MAA8C,IAK9CC,EAAiD,CACrD,SAAU,QACV,QAAS,OACT,eAAgB,aAClB,EAKMC,EAAY,CAKhB,SAASC,EAA2B,CAClCH,EAAS,IAAIG,EAAQ,KAAMA,CAAO,CACpC,EAMA,WAAWC,EAA4C,CACrD,OAAOJ,EAAS,IAAII,CAAI,CAC1B,EASA,UACEA,EACAZ,EACAI,EACAX,EACK,CACL,MAAMkB,EAAU,KAAK,WAAWC,CAAI,EACpC,GAAI,CAACD,EACH,eAAQ,KAAK,sBAAsBC,CAAI,yCAAyC,EACzEZ,EAIT,MAAMa,EAAgBpB,GAASkB,EAAQ,OAASF,EAASG,CAAI,EAGvDE,EAAmBZ,EAAQ,CAC/B,QAAAF,EACA,MAAAI,EACA,MAAOS,CAAA,CACR,EAGD,OAAOF,EAAQ,UAAUG,CAAgB,CAC3C,EAKA,iBAA4B,CAC1B,OAAO,MAAM,KAAKN,EAAS,KAAA,CAAM,CACnC,EAKA,OAAQ,CACNA,EAAS,MAAA,CACX,CACF"}